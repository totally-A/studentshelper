<!DOCTYPE html>
<html>
<head>
	<title>Student's Helper: Типи змінних</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="../css/style.css">
	<link rel="stylesheet" href="../css/articles.css">
	<link rel="shortcut icon" href="../img/icons/mortarboard.ico">

	<!-- Bootsrap feauters -->
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="../bootstrap-3.3.6-dist/css/bootstrap.min.css">

	<!-- Optional theme -->
	<link rel="stylesheet" href="../bootstrap-3.3.6-dist/css/bootstrap-theme.min.css">

	<!-- Latest compiled and minified JavaScript -->
	<script src="../bootstrap-3.3.6-dist/js/bootstrap.min.js"></script>

	<!-- Font Awesome -->
	<link rel="stylesheet" href="../font-awesome-4.6.3/css/font-awesome.min.css">

	<!-- Fonts -->
	<link href='https://fonts.googleapis.com/css?family=Jura:600&subset=latin,cyrillic,cyrillic-ext' rel='stylesheet' type='text/css'>
	<link href='https://fonts.googleapis.com/css?family=Oswald' rel='stylesheet' type='text/css'>
	<link href='https://fonts.googleapis.com/css?family=Lobster&subset=latin,cyrillic' rel='stylesheet' type='text/css'>
</head>
<body>
	<header>
		<div class="wrapper">
			<a href="../index.html" class="logo">
				<div class="emblem">
					
				</div>
				<div class="text">
					Student's Helper
				</div>			
			</a>
			<div class="top-nav">
				<nav>
					<ul>
						<a href="../index.html">
							<li class="general">Головна
								<div class="arrow"></div>
							</li>
						</a>
						<a href="../theory.html">
							<li class="theory">Теорія
								<div class="arrow"></div>
							</li>
						</a>
						<a href="../tests.html">
							<li class="tests">Тести
								<div class="arrow"></div>
							</li>
						</a>
					</ul>
				</nav>
			</div>
		</div>
	</header>
	<div class="main">
		<div class="wrapper">
			<div class="info">
				<h2>
					Локальні та глобальні змінні у мові С 
				</h2>
				<p>
					Кожна змінна має свою зону видимості, тобто таку область, в якій можна працювати зі змінною. За межами цієї області, про змінну нічого відомо не буде, а значить і використовувати її не можна. Отже, змінна знаходиться в області видимості, якщо до неї можна отримати доступ.
				</p>
				<p>
					Існують локальні і глобальні змінні. Так ось, змінні, оголошені всередині функції, називаються локальними. Локальні змінні мають свої області видимості, цими областями є функції, в яких оголошено змінні. Таким чином, в різних функціях можна використовувати змінні з однаковими іменами, що в свою чергу дуже зручно. Поділ змінних на глобальні та локальні відповідає одному з головних правил програмування, а саме - принципом найменших привілеїв. Тобто, змінні, оголошені всередині однієї функції, повинні бути доступні тільки для цієї функції і ні до яких інших, в кінці кінців, вони створювалися саме для цієї функції. Глобальні змінні оголошуються поза тілом будь-якої функції, і тому область видимості таких змінних поширюється на всю програму. Зазвичай глобальні змінні оголошуються перед головною функцією, але можна оголошувати і після функції main (), але тоді ця змінна не буде доступна в функції main ().
				</p>
				<h3>
					Типові помилки
				</h3>
				<ul class="main-info">
					<li>Глобальні змінні порушують принцип мінімальних привілегій та є прикладом поганого стилю програмування.</li>
					<li>Оголошення змінної як глобальної, а не локальної може призвести до випадкових побічних ефектів, коли функція, якій не потрібен доступ до цієї змінної, випадково або навмисно її змінить.</li>
				</ul>

				<div class="example">
					<h3>
					Приклад програми
				</h3>
				<p>
					Розробимо програму, в якій будуть оголошені дві змінні, локальна і глобальна, з однаковим ім'ям.
				</p>
				<pre>
//defines the entry point for the console application
#include < iostream >
using namespace std;

void example();
int variable = 48; //initialization of a global variable

int main()
{
	system("color F0");
	int variable = 12; //initialization of a local variable
	cout << "local  variable = " << variable << endl; //printing value contained in the local variable
	example(); //function start
	system("pause");
}

void example()
{
	cout << "global variable = " << variable << endl; //function sees only the global variable
}

				</pre>
</div>
				<h2>
					Покажчики
				</h2>
				<p>
					Покажчик - змінна, значенням якої є адреса комірки пам'яті. Тобто покажчик посилається на блок даних з області пам'яті, причому на саме його початок. Покажчик може посилатися на змінну або функцію. Для цього потрібно знати адресу змінної або функції. Так ось, щоб дізнатися адресу конкретної змінної в С існує унарна операція взяття адреси &. Така операція витягує адресу оголошених змінних, для того, щоб його привласнити покажчику.<br/>
Покажчики використовуються для передачі по посиланню даних, що набагато прискорює процес обробки цих даних (в тому випадку, якщо обсяг даних великий), так як їх не треба копіювати, як при передачі за значенням, тобто, використовуючи ім'я змінної. В основному покажчики використовуються для організації динамічного розподілу пам'яті, наприклад при оголошенні масиву, не треба буде його обмежувати в розмірі. Адже програміст заздалегідь не може знати, якого розміру потрібен масив того чи іншого користувачеві, в такому випадку використовується динамічне виділення пам'яті під масив. Будь-покажчик необхідно оголосити перед використанням, як і будь-яку змінну.<br/>
Принцип оголошення покажчиків такий же, як і принцип оголошення змінних. Відмінність полягає лише в тому, що перед ім'ям ставиться символ зірочки *. Візуально покажчики відрізняються від змінних тільки одним символом. При оголошенні покажчиків компілятор виділяє кілька байт пам'яті, в залежності від типу даних відводяться для зберігання деякої інформації в пам'яті. Щоб отримати значення, записане в деякій області, на яке посилається покажчик потрібно скористатися операцією разименованія покажчика *. Необхідно поставити зірочку перед ім'ям і отримаємо доступ до значення покажчика.
				</p>
				<h3>
					Типові помилки
				</h3>
				<ul class="main-info">
					<li>Знак операції адресації * не розповсюджується на усі змінні у рядку оголошення. Символ * повинен бути біля імені кожного покажчика.</li>
					<li>Розименування покажчика, який не був ініціалізований або якому не присвоїли необхідне значення адреси призводить до фатальної помилки під час виконання програми або випадковому псуванню даних, в результаті чого виконання програми завершується невірним результатом.</li>
					<li>
						Не розименовуйте покажчик, окрім випадку, коли вам потрібно отримати значення, на яке він посилається.
					</li>
				</ul>
				<div class="example">
					<h3>
					Приклад програми
				</h3>
				<p>
					Розробимо програму, яка буде порівнювати адреси покажчиків.
				</p>
				<pre>
#include < iostream >
using namespace std;

int main()
{
	system("color F0");
	int var1 = 123;                             //initializing the variable var1 number 123
	int var2 = 99;                              //initializing the variable var2 number 99
	int *ptrvar1 = &var1;                       //a pointer to the variable var1
	int *ptrvar2 = &var2;                       //a pointer to the variable var2
	cout << "var1    = " << var1 << endl;
	cout << "var2    = " << var2 << endl;
	cout << "ptrvar1 = " << ptrvar1 << endl;
	cout << "ptrvar2 = " << ptrvar2 << endl;
	if (ptrvar1 > ptrvar2)                      //we compare the values of pointers, ie variables addresses
		cout << "ptrvar1 > ptrvar2" << endl;
	if (*ptrvar1 > *ptrvar2)                    //we compare the values of variables that are referenced by pointers
		cout << "*ptrvar1 > *ptrvar2" << endl;
	system("pause");
}
				</pre>
</div>
				<p>
					Завантажте "Аналіз коду" для подробиць.
				</p>

				<h2>
					Модифікатор Const у мові С
				</h2>
				<p>
					Модифікатор типу const (від анг type qualifier) - pарезервоване ключове слово у мові програмування С, яке не дає модифікувати значення змінних. Звідси і виникло в програмуванні таке поняття, як константи або константні змінні, тобто незмінні. Необхідно запам'ятати, що при оголошенні константи, її потрібно ініціалізувати.<br/>
// Синтаксис оголошення константи<br/>
Const / * тип даних * / / * ім'я змінної * / = / * ініціалізатор (значення) * /; // Оголошення константної змінної<br/>
Оголошення константної змінної від звичайної змінної відрізняється ключовим словом const, яке ставиться перед типом даних оголошення змінної. Розглянемо фрагмент коду оголошення константній змінної.<br/>
// Оголошення і ініціалізація константній змінної типу INT з ім'ям значення<br/>
const int value = 8;<br/>
Значення Const = 8;<br/>
Була оголошена константа цілого типу з іменем і ініціалізована значенням 8.

				</p>
				<h3>
					Типові помилки
				</h3>
				<ul class="main-info">
					<li>Використання змінних з модифікатором const в оголошеннях масивів і поміщення змінних з модифікатором const у заголовні файли (котрі включаються у різні вихідні файли однієї і тієї ж програми) заборонено у мову С, але дозволено у С++.</li>
					<li>Ініціалізація змінної const не константним виразом, наприклад змінною, не оголошеною з модифікатором const.</li>
					<li>Спроба змінити константну змінну.</li>
					<li>Спроба змінити константний покажчик.</li>
				</ul>
				<div class="example">
					<h3>
					Приклад програми
				</h3>
				<p>
					Умова задачі: Маємо певне стале значення виразу, у нашому випадку – це швидкість, яку не можна перевищувати і три швидкості: 85, 95, 100. Визначити штраф, який заплатить водій, проїхавши крізь дану дорогу з лімітом швидкості.
				</p>
				<pre>
//Using constants
#include < stdio.h >
#include < iostream >
const int SPEEDLIMIT = 55;
const int RATE = 15;
const int FIRST_TICKET = 85;
const int SECOND_TICKET= 95;
const int THIRD_TICKET = 100;
int main()
{
	system("color F0");
	int total, fine, speeding;
	total = 0;
	puts("Speeding Tickets\n");
	/* first ticket */
	speeding = FIRST_TICKET - SPEEDLIMIT;
	fine = speeding * RATE;
	total = total + fine;
	printf("For going %d in a %d zone: $%d\n", FIRST_TICKET, SPEEDLIMIT, fine);
	/* second ticket */
	speeding = SECOND_TICKET - SPEEDLIMIT;
	fine = speeding * RATE;
	total = total + fine;
	printf("For going %d in a %d zone: $%d\n", SECOND_TICKET, SPEEDLIMIT, fine);
	/* third ticket */
	speeding = THIRD_TICKET - SPEEDLIMIT;
	fine = speeding * RATE;
	total = total + fine;
	printf("For going %d in a %d zone: $%d\n", THIRD_TICKET, SPEEDLIMIT, fine);
	/* Display total */
	printf("\nTotal in fines: $%d\n", total);
	system("pause");
}

				</pre>
</div>
				<p>
					Завантажте "Аналіз коду" для подробиць.
				</p>
				<p class="res">
					Ресурси: http://cppstudio.com/post/394/
					<br/>http://cppstudio.com/post/415/
				</p>
			</div>
			<div class="buttons">
				<a href="../material/Variables.zip" class="review button" download>
					Аналіз коду
				</a>
			</div>

			<a href="../mistakes.html" class="back-btn"><i class="fa fa-long-arrow-left" aria-hidden="true"></i>Назад</a>	
		</div>
	</div>
	<footer>
		<div class="wrapper">
			<div class="line-1">
				<div class="short-info">
					Student's Helper - це український волонтерський проект, розроблений для того, щоб допомогти студенту у галузі програмування.
				</div>
				<div class="bot-nav">
					<nav>
						<ul>
							<a href="../documentation.html">
								<li>Про проект</li>
							</a>
							<a href="../devs.html">
								<li>Розробники</li>
							</a>
						</ul>
					</nav>
				</div>
			</div>		
			<div class="line-2">
				© 2016 Найкраща тіма на світі. Усі права захищені.
			</div>	
		</div>
	</footer>
</body>
</html>