<!DOCTYPE html>
<html>
<head>
	<title>Student's Helper: Масиви</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="../css/style.css">
	<link rel="stylesheet" href="../css/articles.css">
	<link rel="shortcut icon" href="../img/icons/mortarboard.ico">

	<!-- Bootsrap feauters -->
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="../bootstrap-3.3.6-dist/css/bootstrap.min.css">

	<!-- Optional theme -->
	<link rel="stylesheet" href="../bootstrap-3.3.6-dist/css/bootstrap-theme.min.css">

	<!-- Latest compiled and minified JavaScript -->
	<script src="../bootstrap-3.3.6-dist/js/bootstrap.min.js"></script>

	<!-- Font Awesome -->
	<link rel="stylesheet" href="../font-awesome-4.6.3/css/font-awesome.min.css">

	<!-- Fonts -->
	<link href='https://fonts.googleapis.com/css?family=Jura:600&subset=latin,cyrillic,cyrillic-ext' rel='stylesheet' type='text/css'>
	<link href='https://fonts.googleapis.com/css?family=Oswald' rel='stylesheet' type='text/css'>
	<link href='https://fonts.googleapis.com/css?family=Lobster&subset=latin,cyrillic' rel='stylesheet' type='text/css'>
</head>
<body>
	<header>
		<div class="wrapper">
			<a href="../index.html" class="logo">
				<div class="emblem">
					
				</div>
				<div class="text">
					Student's Helper
				</div>			
			</a>
			<div class="top-nav">
				<nav>
					<ul>
						<a href="../index.html">
							<li class="general">Головна
								<div class="arrow"></div>
							</li>
						</a>
						<a href="../theory.html">
							<li class="theory">Теорія
								<div class="arrow"></div>
							</li>
						</a>
						<a href="../tests.html">
							<li class="tests">Тести
								<div class="arrow"></div>
							</li>
						</a>
					</ul>
				</nav>
			</div>
		</div>
	</header>
	<div class="main">
		<div class="wrapper">
			<div class="info">
				<h2>
					Масиви
				</h2>
				<p>
					 Маси́в — впорядкований набір фіксованої кількості однотипних елементів, що зберігаються в послідовно розташованих комірках оперативної пам'яті, мають порядковий номер і спільне ім'я, що надає користувач.
				</p>
				<p>
					  Характеристика масиву
				</p>
				<ol>
					<li>Розмірність — кількість індексів елемента (одновимірний, двовимірний, ..., багатовимірний)</li>
					<li>Розмір — загальна кількість елементів у масиві.</li>
					<li>За типом поділяється на числовий та символьний.</li>
					<li>В кожній мові є свої правила опису масив (у мові Бейсик — командою DIM <список масивів>]]).</li>
				</ol>
				<p>
					В програмуванні масив (англ. array) — сукупність елементів одного типу даних, впорядкованих за індексами, які зазвичай репрезентовані натуральними числами, що визначають положення елемента в масиві.<br/>
Масив може бути одновимірним (вектором), та багатовимірним (наприклад, двовимірною таблицею), тобто таким, де індексом є не одне число, а кортеж(сукупність) з декількох чисел, кількість яких збігається з розмірністю масиву.<br/>
У переважній більшості мов програмування масив є стандартною вбудованою структурою даних.
				</p>
				<h3>Види сортувань у масивах у мові С</h3>
				<p>Бульбашкове сортування<br/><br/>
Умовно домовимося вважати масив відсортованим, якщо елементи розташовані в порядку зростання. Усі приклади будемо розглядати на типі int, проте він може бути замінений будь-яким іншим порівнянним типом даних. Розгляд методів сортування почнемо з сортування бульбашкою (BubbleSort). Це один з найпростіших методів сортування, який зазвичай входить в шкільний курс програмування. Назва методу відображає його сутність: на кожному кроці «найлегший» елемент піднімається до свого місця ( «спливає»). Для цього ми переглядаємо всі елементи знизу вгору, беремо пару сусідніх елементів у випадку, якщо вони стоять неправильно, міняємо їх місцями. Замість підняття «найлегшого» елемента можна «топити» найважчий. Оскільки за кожен крок на своє місце встає рівно 1 елемент, то нам буде потрібно виконати N кроків.<br/>
Програму сортування можна записати так:
</p>
				<pre>
#include< stdio.h >
#define N 1000
int main() {
	int n, i, j;
	int a[N];
	//read number of n
	scanf_s("%d", &n);

	//read n numbers
	for (i = 0; i < n; i++) {
		scanf_s("%d", &a[i]);
	}
	for (i = 0; i < n - 1; i++) {
		//compare two elements
		for (j = 0; j < n - i - 1; j++) {
			if (a[j] > a[j + 1]) {
				//if they are not in the corrent order
				//change them
				int tmp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = tmp;
			}
		}
	}
}
				</pre>
				<p>
					Алгоритм не використовує додаткової пам'яті, тобто всі дії здійснюються на одному і тому ж масиві. Складність алгоритму сортування бульбашкою становить O (N2), кількість операцій порівняння: N (N-1) / 2. Це дуже погана складність, але алгоритм має два плюси.<br/>
По-перше, він легко реалізується, а значить, може і повинен застосовуватися в тих випадках, коли потрібно одноразова сортування масиву. При цьому розмір масиву не повинен бути більше 10000, тому що інакше алгоритм сортування бульбашки не буде укладатися у відведений час.<br/>
По-друге, сортування бульбашкою використовує тільки порівняння і перестановки сусідніх елементів, а значить, може використовуватися в тих завданнях, де явно дозволений тільки такий обмін і для сортування, наприклад, списків. Існують різноманітні оптимізації сортування бульбашкою, які ускладнюють (а нерідко і збільшують час роботи алгоритму), але не приносять вигоди ні в плані складності, ні в плані швидкодії. На цьому плюси сортування бульбашкою закінчуються. Надалі ми ще більше звузимо область застосування сортування бульбашкою.
<br/><br/>				</p>

				<p>
					Сортування прямим вибором<br/><br/>
					Розглянемо ще один квадратичний алгоритм, який, однак, є оптимальним за кількістю присвоювання і може бути використаний, коли за умовою задачі необхідно явно мінімізувати кількість присвоювання. Суть методу полягає в наступному: ми будемо вибирати мінімальний елемент в решті масиву і приписувати його до вже відсортованої частини. повторивши ці дії N раз, ми отримаємо відсортований масив.
				</p>
				<pre>
#include < stdio.h >
void selectionSort(int *num, int size)
{
	int i, j;
	int min, temp;
	for (i = 0; i < size - 1; i++)
	{
		min = i;
		for (j = i + 1; j < size; j++)
		{
			if (num[j] < num[min])
				min = j;
		}
		temp = num[i];
		num[i] = num[min];
		num[min] = temp;
	}
}
int main()
{
	int a[10];
	int i, j, index;
	for (i = 0; i < 10; i++)
	{
		printf("a[%d] = ", i);
		scanf("%d", &a[i]);
	}
	selectionSort(a, 10);
	for (i = 0; i < 10; i++)
		printf("%d ", a[i]);
	getchar(); getchar();
	return 0;
}
				</pre>
				<p>Кількість порівнянь становить O (N2), а кількість присвоювання всього O (N). В цілому це поганий метод і він повинен бути використаний тільки в випадках, коли явно необхідно мінімізувати кількість присвоювання.<br/><br/></p>

				<p>
					Пірамідальне сортування (HeapSort)<br/><br/>
					Почнемо розгляд ефективних алгоритмів сортування (працюють за O (NlogN)) з пірамідальною сортування, в якій використовуються знайомі нам ідеї купи. Ми будемо вибирати з купи найбільший елемент, і записувати його в початок вже відсортованої частини масиву. Тобто відсортований масив буде будуватися від кінця до початку. Такі хитрощі необхідні, щоб не було необхідності в додатковій пам'яті і для прискорення роботи алгоритму - купа буде розташовуватися на початку масиву, а відсортована частина буде перебувати після купи.
				</p>
				<pre>
#include < stdio.h >

#define MAXL 1000

void swap(int *a, int *b)
{
	int t = *a;
	*a = *b;
	*b = t;
}
int main()
{
	int a[MAXL], n, i, sh = 0, b = 0;
	scanf("%i", &n);
	for (i = 0; i < n; ++i)
		scanf("%i", &a[i]);
	while (1)
	{
		b = 0;
		for (i = 0; i < n; ++i)
		{
			if (i * 2 + 2 + sh < n)
			{
				if (a[i + sh] > a[i * 2 + 1 + sh] || a[i + sh] > a[i * 2 + 2 + sh])
				{
					if (a[i * 2 + 1 + sh] < a[i * 2 + 2 + sh])
					{
						swap(&a[i + sh], &a[i * 2 + 1 + sh]);
						b = 1;
					}
					else if (a[i * 2 + 2 + sh] < a[i * 2 + 1 + sh])
					{
						swap(&a[i + sh], &a[i * 2 + 2 + sh]);
						b = 1;
					}
				}
			}
			else if (i * 2 + 1 + sh < n)
			{
				if (a[i + sh] > a[i * 2 + 1 + sh])
				{
					swap(&a[i + sh], &a[i * 2 + 1 + sh]);
					b = 1;
				}
			}
		}
		if (!b) sh++;
		if (sh + 2 == n)
			break;
	}
	for (i = 0; i < n; ++i)
		printf("%i%c", a[i], (i != n - 1) ? ' ' : '\n');
	return 0;
}
				</pre>
				<p>
					Ця функція отримує покажчик на масив, номер елемента, який необхідно проштовхнути і розмір купи. У неї є невеликі відмінності від звичайних функцій роботи з купою. Номер мінімального предка зберігається в змінної y, якщо необхідність в обмінах закінчена, то ми виходимо з циклу і записуємо просіяне змінну на призначене їй місце. Саме сортування буде складатися з створення купи з масиву і N переносів елементів з вершини гори з подальшим відновленням властивості купи:<br/>
Всього в процесі роботи алгоритму буде виконано 3N / 2-2 виклику функції down_heap, кожен з яких займає O (logN). Таким чином, ми і отримуємо шукану складність в O (NlogN), при цьому, не використовуючи додаткової пам'яті. Кількість присвоювання також становить O (NlogN). Пірамідальну сортування слід здійснювати, якщо з умови задачі зрозуміло, що єдиною дозволеною операцією є «проштовхування» елемента по купі.<br/><br/>
				</p>
				<p>
					Швидке сортування(QuickSort)<br/><br/>
					Ми вже розглядали ідеї, які використовуються в швидкої сортування, при пошуку порядкових статистик. Точно так же, як і в тому алгоритмі, ми вибираємо якийсь опорний елемент і всі числа, менші його переміщаємо в ліву частину масиву, а всі числа великі його - в праву частину. Потім викликаємо функцію сортування для кожної з цих частин. Таким чином, наша функція сортування повинна приймати покажчик на масив і дві змінні, що позначають ліву і праву межу сортованої області.<br/>
Зупинимося детальніше на виборі опорного елемента. У деяких книгах рекомендується вибирати випадковий елемент між лівою і правою кордоном. Хоча теоретично це красиво і правильно, але на практиці слід враховувати, що функція генерації випадкового числа досить повільна і такий метод помітно погіршує продуктивність алгоритму в середньому. Найбільш часто використовується середина області, тобто елемент з індексом (l + r) / 2. При такому підході використовуються швидкі операції складання і розподілу на два, і в цілому він працює досить не погано. Однак в деяких завданнях, де суттю є виключно сортування, хитре журі спеціально підбирає тести так, щоб «завалити» стандартну швидку сортування з вибором опорного елемента з середини. Варто помітити, що це досить рідкісна ситуація, але все ж варто знати, що можна вибирати довільний елемент з індексом m так, щоб виконувалася нерівність l ≤ m ≤ r. Щоб ця умова виконувалася, досить вибрати довільні два числа x і y і вибирати m виходячи з наступного співвідношення: m = (x · l + y · r) / (x + y). В цілому такий метод буде незначно програвати вибору середнього елемента, тому що вимагає двох додаткових умножений.<br/>
Наведемо текст функції швидкого сортування з вибором середнього елемента в якості опорного:
				</p>
				<pre>
#include < iostream >
using namespace std;
int a[100];
void quickSort(int l, int r)
{
	int x = a[l + (r - l) / 2]; 
	int i = l;
	int j = r;
	while (i <= j)
	{
		while (a[i] < x) i++;
		while (a[j] > x) j--;
		if (i <= j)
		{
			swap(a[i], a[j]);
			i++;
			j--;
		}
	}
	if (i < r)
		quickSort(i, r);

	if (l < j)
		quickSort(l, j);
}
int main()
{
	int n;//number of elements in array
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
	}
	quickSort(0, n - 1);
	for (int i = 0; i < n; i++)
	{
		cout << a[i] << " ";
	}
	return 0;
}
				</pre>
				<p>
					Тут ми не передаємо ліву кордон в явному вигляді, а користуємося показниковою арифметикою. Це робить використання функції швидкого сортування зручнішим, тому що в неї треба просто передати масив і кількість елементів в ньому (як і в інших видах сортування).<br/>
Алгоритм швидкого сортування в середньому використовує O (NlogN) порівнянь і O (NlogN) присвоювання (на практиці навіть менше) і використовує O (logN) додаткової пам'яті і використовує O (N) додаткової пам'яті, однак імовірність виникнення гіршого випадку вкрай мала: на кожному кроці ймовірність найгіршого випадку дорівнює 2 / N, де N – поточний кількість елементів.<br/>
Розглянемо можливі оптимізації методу швидкого сортування. По-перше, при виклику рекурсивної функції виникають накладні витрати на зберігання локальних змінних (які нам не особливо потрібні при рекурсивних викликах) і інший службовою інформацією. Таким чином, при заміні рекурсії стеком ми отримаємо невеликий приріст продуктивності і невелике зниження необхідного обсягу додаткової пам'яті. По-друге, як ми знаємо, виклик функції - досить накладна операція, а для невеликих масивів швидке сортування працює не дуже добре. Тому, якщо при виконанні функції сортування в масиві знаходиться менше, ніж K елементів, розумно використовувати будь-якої нерекурсивний метод, наприклад, сортування вставками або вибором. Число K при цьому вибирається в районі 20, конкретні значення підбираються дослідним шляхом. Така модифікація може дати до 15% приросту продуктивності. Швидку сортування можна використовувати і для двусвязного списків (тому що в ній здійснюється тільки послідовний доступ з початку і з кінця), але в цьому випадку виникають проблеми з вибором опорного елемента - його доводиться брати першим або останнім в сортованої області. Цю проблему можна вирішити якимось набором псевдовипадкових перестановок елементів списку, тоді навіть якщо дані були підібрані спеціально, ефект нейтралізується.<br/><br/>
				</p>
				<p>
					Сортування злиттям(MergeSort)<br/><br/>
					Сортування злиттями також грунтується на ідеї, яка вже була нами порушена при розгляді алгоритму пошуку двох максимальних елементів. У цьому алгоритмі ми спочатку розіб'ємо елементи на пари і впорядкуємо їх усередині пари. Потім з двох пар створимо впорядковані четвірки і т.д. Інтерес представляє сам процесс злиття: для кожної з  половинок ми встановлюємо покажчики на початок, дивимося, в який з частин елемент за вказівником менше, записуємо цей елемент в новий масив і переміщаємо відповідний покажчик.
				</p>
				<pre>
#include < stdio.h >
#include < stdlib.h >
#define SIZE 16
int merge_sort(int *a, int l, int r) {
	if (l == r) return 0;
	int mid = (l + r) / 2;
	merge_sort(a, l, mid);
	merge_sort(a, mid + 1, r);
	int * tmp;
	int i = l;
	int j;
	j = mid + 1;
	tmp = (int*)malloc(r*sizeof(int));
	for (int step = 0; step < r - l + 1; step++) {
		if ((j>r) || ((i <= mid) && (a[i] < a[j]))) {
			tmp[step] = a[i];
			i++;
		}
		else {
			tmp[step] = a[j];
			j++;
		}
	}
	for (int step = 0; step < r - l + 1; step++)
		a[l + step] = tmp[step];
}
int main() {
	int a[SIZE];
	int i;
	for (i = 0; i < SIZE; i++) {
		a[i] = (rand() % 100);
		printf(" %d ", a[i]);
	}
	merge_sort(a, 0, SIZE - 1);
	printf("\n");
	for (i = 0; i < SIZE; i++)
		printf(" %d ", a[i]);
	getchar();
	return 0;
}
				</pre>
				<p>
					Рекурсивна реалізація сортування злиттям дещо простіше, але має меншу ефективністю і вимагає O (logN) додаткової пам'яті. Алгоритм має складність O (NlogN) і вимагає O (N) додаткової пам'яті. В оригіналі цей алгоритм був придуманий для сортування даних у зовнішній пам'яті (Дані були розташовані в файлах) і вимагає лише послідовного доступу. Цей алгоритм застосуємо для сортування однозв'язних списків.<br/><br/>
				</p>
				<p>
					Сортування підрахунком (PigeonholeSort)<br/><br/>
					Це сортування може використовуватися тільки для дискретних даних. Припустимо, у нас є числа від 0 до 99, які нам слід впорядкувати. Заведемо масив розміром в 100 елементів, в якому будемо запам'ятовувати, скільки разів зустрічалося кожне число (тобто при появі числа будемо збільшувати елемент допоміжного масиву з індексом, рівним цього числа, на 1). Потім просто пройдемо по всім числам від 0 до 99 і виведемо кожне стільки разів, скільки воно зустрічалося. Сортування реалізується в такий спосіб:
				</p>
				<pre>
#include < iostream >
using namespace std;
int a[100];
int c[100];
int main()
{
	int n;//number of elements in array
	int k = 100;
	cin >> n;
	//read array
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
	}
	//build array
	for (int i = 0; i < n; i++)
	{
		c[a[i]]++;
	}
	//run from the
	//0 до k-1
	for (int i = 0; i < k; i++)
	{
		//input i c[i] times
		for (int j = 0; j < c[i]; j++)
			cout << i << " ";
	}
	return 0;
}
				</pre>
				<p>
					Тут MAXV - максимальне значення, яке може зустрічатися (тобто всі числа масиву повинні лежати в межах від 0 до MAXV-1). Алгоритм використовує O (MAXV) додаткової пам'яті і має складність O (N + MAXV). Його застосування дає відмінний результат, якщо MAXV набагато менше, ніж кількість елементів в масиві.<br/><br/>
				</p>
				<p>
					Порозрядне сортування (RadixSort)<br/><br/>
					Алгоритм сортування підрахунком надзвичайно привабливий своєю високою продуктивністю, але вона погіршується при зростанні MAXV, також різко зростають вимоги до додаткової пам'яті. Фактично, неможливо здійснити сортування підрахунком для змінних типу unsigned int (MAXV при цьому одно 232). Як розвитку ідеї сортування підрахунком розглянемо порозрядну сортування. Спочатку відсортуємо числа за останнім розряду (одиниць). Потім повторимо те ж саме для другого і наступних розрядів, користуюся якихось стійким алгоритмом сортування.<br/><br/>
Для самого сортування будемо використовувати сортування підрахунком. Після цього будемо переробляти отриману таблицю так, щоб для кожного можливого значення розряду зберігалася позиція, починаючи з якої йдуть числа з таким значенням у відповідному розряді. Назвемо цей масив c. Після цього будемо проходити по всьому вихідного масиву, дивитися на поточний значення розряду (i), записувати поточне число у допоміжний масив (b) на позицію c [i], а потім збільшувати c [i].<br/><br/>
Нехай кількість знаків у числі одно k, а кількість можливих значень дорівнює m (Система числення, використана під час запису числа). Тоді кількість присвоювання, вироблене алгоритмом, дорівнюватиме O (kN + km), а кількість додаткової пам'яті - O (N + km). Наведемо ефективну реалізацію поразрядной сортування для беззнакових 4 байтних чисел (unsigned int). Ми будемо використовувати 4 розряду, кожен з яких дорівнює байту (система числення з основою 256). Ця реалізація використовує кілька хитрощів, які будуть пояснені нижче.
				</p>
				<pre>
void radix_sort(unsigned int a[], int n)
{
	unsigned int *t, *a2 = a;
	unsigned int *b = (unsigned int*)malloc(n*sizeof(int)), *b2;
	unsigned char *bp;
	int i, j, npos, temp;
	int c[256][4];
	b2 = b;
	memset(c, 0, sizeof(int) * 256 * 4);
	bp = (unsigned char*)a;
	For(i, n)
		For(j, 4)
	{
		c[*bp][j]++; bp++;
	}
	For(j, 4)
	{
		npos = 0;
		For(i, 256)
		{
			temp = c[i][j];
			c[i][j] = npos;
			npos += temp;
		}
	}
	For(j, 4)
	{
		bp = (unsigned char*)a2 + j;
		For(i, n)
		{
			b[c[*bp][j]++] = a2[i];
			bp += 4;
		}
		t = a2; a2 = b; b = t;
	}
	free(b2);
}
				</pre>
				<p>
					Функція memset використовується для заповнення заданої області пам'яті нулями (Обнулення масиву), вона знаходиться в бібліотеці string.h. Всю таблицю зрушень (c) ми будемо будувати заздалегідь для всіх 4 розрядів. Для ефективно доступу до окремих байтів ми використовуватимемо покажчик bp типу unsigned char * (тип char якраз займає 1 байт і може трактуватися як число). Потім ми формуємо модифіковану таблицю і проводимо власне функцію розстановки чисел по всіх 4 розрядами.<br/>
Уважний читач помітить у наведеній функції кілька місць, які на перший погляд здаються помилковими. Хоча в текстовому описі ми і говорили, що слід сортувати, починаючи з останніх розрядів, в реалізації ми починаємо з перших байтів. Це пояснюється тим, що в архітектурі x86 числа зберігаються в «перевернутому» вигляді - це було зроблено для сумісності з молодшими моделями. Друге можливе місце для помилки - масив a не ставиться у відповідність вказівником відсортованого масиву і не здійснюється копіювання відсортованих елементів в нього в кінці роботи функції. Це пов'язано з парною кількістю розрядів, так що результат в підсумку і так виявляється в масиві a. Взагалі кажучи, далеко не обов'язково так сильно пов'язувати порозрядну сортування з апаратними засобами. Більш того, основне зручність поразрядной сортування полягає в там, що з її допомогою можна сортувати складні структури, такі як дати, рядки (Масиви) та інші структури з багатьма полями.
				</p>
				<h3>
					Типові помилки
				</h3>
				<ul class="main-info">
					<li>Важливо розуміти різницю між «сьомим елементом масиву» і «елементом масиву номер сім». Оскільки індекси масиву починаються з нуля, «сьомий елемент масиву» має індекс шість, в той час, як «елемент масиву номер сім» має індекс сім і фактично є восьмим елементом масиву. Це джерело помилок зміщення індексу.</li>
					<li>Відсутній ініціалізації масиву, елементи якого повинні бути ініціалізовані.</li>
					<li>Вказання у списку ініціалізації більшого числа значень, ніж кількість елементів у масиві, є синтаксичною помилкою.</li>
					<li>Посилання на елемент за межами масиву.</li>
					<li>Передача функції scanf символьного масиву, недостатньо великого для зберігання введеного з клавіатури рядка, може призвести до втрат даних у програмі та інших помилок часу виконання.</li>
					<li>Припущення, що елементи локального масиву, оголошеного як static, ініціалізуються нулями кожний раз при виклику функції, де цей масив оголошений.</li>
					<li>Невірне посилання на елемент двомірного масиву a[x][y] у вигляді a[x,y].</li>
				</ul>
				<h2>
					Сортування рядків
				</h2>
				<p>
					До сих пір ми сортували тільки масиви символів. Очевидно, що наведені функції можна переробити для сортування масивів будь-якого з вбудованих типів даних, просто помінявши типи параметрів і змінних. Проте, зазвичай виникає необхідність сортувати складні типи даних, наприклад рядки, або агреговані дані, наприклад структури. Більшість завдань сортування мають справу з ключем і інформацією, пов'язаною з цим ключем. Щоб адаптувати алгоритми для обробки подібних даних, необхідно модифікувати код порівняння, код обміну або обидва фрагмента. Сам алгоритм при цьому не змінюється.<br/>
Оскільки швидке сортування в даний час є одним з кращих методів сортування загального призначення, воно використовується в наступних прикладах. Проте, той же принцип стосується і до всіх інших методів, описаних раніше.<br/>
Сортування рядків є поширеною завданням програмування. Рядки найлегше сортувати, коли вони зберігаються в таблиці рядків. Таблиця рядків - це просто масив рядків. А масив рядків - це двовимірний масив символів, в якому кількість рядків в таблиці визначається розміром лівого вимірювання, а максимальна довжина рядка - розміром правого виміру. Нижченаведена строкова версія швидкого сортування приймає масив рядків, в якому розмір кожного рядка обмежений десятьма символами. (Можете змінити цю довжину, якщо хочете.) наведемо приклад програми, яка у звичайному рядку видаляє усі символи, що повторюються, а потім, ті символи, що залишилися – розміщує за алфавітом. Код програми:<br/>

				</p>
				<pre>
//Sorting of string
#include < stdio.h >
#include < string.h >
#include < iostream >

void main()
{
	system("color F0");
	int i, j = 0, k = 0;
	char str[100], str1[10][20], temp, min;

	printf("Enter the string:");
	scanf("%[^\n]s", str);

	/* ignores spaces */
	for (i = 0; str[i] != '\0'; i++)
	{
		if (str[i] == ' ')
		{
			for (j = i; str[j] != '\0'; j++)
			{
				str[j] = str[j + 1];
			}
		}
	}

	/* removes repeated characters */
	for (i = 0; str[i] != '\0'; i++)
	{
		for (j = i + 1; str[j] != '\0'; j++)
		{
			if (str[i] == str[j])
			{
				for (k = j; str[k] != '\0'; k++)
					str[k] = str[k + 1];
				j--;
			}
		}
	}

	/* sorts the string */
	for (i = 0; str[i] != '\0'; i++)
	{
		for (j = 0; str[j] != '\0'; j++)
		{
			if (str[j] > str[i])
			{
				temp = str[i];
				str[i] = str[j];
				str[j] = temp;
			}
		}
	}
	printf("%s\n", str);
	system("pause");
}
				</pre>
				<p>
					Завантажте "Аналіз коду" для подробиць.
				</p>
				<h3>
					Типові помилки
				</h3>
				<ul class="main-info">
					<li>При визначенні розміру масиву символів не виділено місця, щоб запам’ятати символ NULL, який обмежує рядок.</li>
					<li>Спроба надрукувати «рядок», який не містить обмежуючого символу NULL.</li>
					<li>Обробка одинарного символу у якості рядка. Рядок – це покажчик, який, можливо, представляється даними типу long int. Символ – це невелике ціле число (значення кодової таблиціASCII знаходяться у діапазоні 0-255). На багатьох системах така заміна викличе помилку, оскільки молодша адреса пам’яті резервується для спеціального використання – наприклад, для адресації програм обробки переривань операційної системи, - так що відбудеться «несанкціонований доступ».</li>
					<li>Передача символу у якості аргументу функції, яка оперує з рядками.</li>
					<li>Передача рядка у якості аргументу функції, яку оперує з символами.</li>
				</ul>
				<p class="res">
					Ресурси: http://lord-n.narod.ru/download/books/walla/programming/Spr_po_C/21/2109.htm
					<br/>
				</p>
			</div>
			<div class="buttons">
				<a href="../material/Arrays and Strings.zip" class="review button" download>
					Аналіз коду
				</a>
			</div>

			<a href="../mistakes.html" class="back-btn"><i class="fa fa-long-arrow-left" aria-hidden="true"></i>Назад</a>	
		</div>
	</div>
	<footer>
		<div class="wrapper">
			<div class="line-1">
				<div class="short-info">
					Student's Helper - це український волонтерський проект, розроблений для того, щоб допомогти студенту у галузі програмування.
				</div>
				<div class="bot-nav">
					<nav>
						<ul>
							<a href="../documentation.html">
								<li>Про проект</li>
							</a>
							<a href="../devs.html">
								<li>Розробники</li>
							</a>
						</ul>
					</nav>
				</div>
			</div>		
			<div class="line-2">
				© 2016 Найкраща тіма на світі. Усі права захищені.
			</div>	
		</div>
	</footer>
</body>
</html>